# Blog Post Repurposing Workflow

This repository contains a Python implementation of various workflows designed to repurpose a blog post into multiple formats such as key points, summaries, social media posts, and email newsletters. The workflows utilize LLMs (Large Language Models) in different configurations, including pipeline workflows, DAG workflows, chain-of-thought reasoning, Reflexion workflows, and agent-driven workflows.

## Table of Contents
1. [Setup Instructions](#setup-instructions)
2. [Implementation Overview](#implementation-overview)
3. [Example Outputs](#example-outputs)
4. [Effectiveness Analysis](#effectiveness-analysis)
5. [Challenges and Solutions](#challenges-and-solutions)

---

## Setup Instructions

### Prerequisites
- Python 3.8 or higher
- OpenAI Python library (`openai`)
- `dotenv` for environment variable management
- A `.env` file with the following variables:
  - `MODEL_SERVER`: Specifies the model server (e.g., "GROQ").
  - API keys and base URLs for your chosen model server (e.g., `GROQ_API_KEY`, `GROQ_BASE_URL`, etc.).

### Installation Steps
1. Clone this repository.
   ```bash
   git clone https://github.com/ZeyadMahfouzz/asgn5
   cd asgn5
   ```

2. Install required dependencies:
   ```bash
   pip install requirments.txt
   ```

3. Create a `.env` file in the root directory and populate it with your credentials:
   ```
   MODEL_SERVER=GROQ
   GROQ_API_KEY=your_groq_api_key_here
   GROQ_BASE_URL=https://api.groq.com/v1
   GROQ_MODEL=groq_model_name
   ```

4. Ensure you have a `sample_blog_post.json` file in the root directory containing a sample blog post in JSON format:
   ```json
   {
       "title": "Your Blog Post Title",
       "content": "Your blog post content goes here."
   }
   ```

5. Run the script:
   ```bash
   python main.py
   ```

---

## Implementation Overview

The code implements several workflows to process a blog post:

1. **Pipeline Workflow**: Executes tasks sequentially (extract key points → generate summary → create social media posts → create email newsletter).
2. **DAG Workflow**: Similar to the pipeline but allows parallel execution where dependencies permit.
3. **Key Points Extraction with Chain-of-Thought Reasoning**: Uses step-by-step reasoning to extract key points more effectively.
4. **Reflexion Workflow**: Applies self-evaluation and iterative improvement to each task for higher-quality outputs.
5. **Agent-Driven Workflow**: Employs an agent that dynamically selects tools to complete the workflow based on intermediate results.

Each workflow interacts with an LLM via API calls, using custom-defined tool schemas to structure inputs and outputs.

---

## Example Outputs

Below are examples of outputs generated by each workflow type. These snippets are illustrative and may vary depending on the input blog post.

### Pipeline Workflow Output
```plaintext
Key Points:
1. Key point extracted from the blog post.
2. Another important takeaway.

Summary:
A concise summary of the blog post.

Social Media Posts:
TWITTER:
Optimized tweet for Twitter/X.

LINKEDIN:
Professional post for LinkedIn.

FACEBOOK:
Engaging post for Facebook.

Email Newsletter:
Subject: Your Email Subject Line
Body: The body of the email newsletter.
```

### Reflexion Workflow Output
```plaintext
Key Points:
1. Improved key point after reflexion.
2. Enhanced takeaway with better clarity.

Summary:
A refined summary incorporating feedback.

Social Media Posts:
TWITTER:
Revised tweet optimized for engagement.

LINKEDIN:
Professional post improved for tone.

FACEBOOK:
Engaging post revised for impact.

Email Newsletter:
Subject: Refined Email Subject Line
Body: Improved email body content.
```

(Other workflow outputs follow a similar structure.)

---

## Effectiveness Analysis

### Pipeline Workflow
- **Strengths**: Simple and straightforward; easy to debug and maintain.
- **Weaknesses**: Sequential execution can be slow, especially if subsequent steps depend heavily on earlier ones.

### DAG Workflow
- **Strengths**: Allows parallelization of independent tasks, reducing overall runtime.
- **Weaknesses**: Slightly more complex to implement due to dependency tracking.

### Chain-of-Thought Reasoning
- **Strengths**: Produces high-quality key points by explicitly breaking down the reasoning process.
- **Weaknesses**: Requires additional computation time for intermediate reasoning steps.

### Reflexion Workflow
- **Strengths**: Iterative evaluation leads to significantly improved quality across all outputs.
- **Weaknesses**: Computationally expensive due to repeated evaluations and corrections.

### Agent-Driven Workflow
- **Strengths**: Highly flexible; adapts dynamically to available tools and intermediate results.
- **Weaknesses**: Complexity increases with the number of tools and decision points.

Overall, the Reflexion Workflow stands out for producing the highest-quality outputs, though at the cost of increased computational overhead. For simpler use cases, the Pipeline or DAG Workflows provide adequate results efficiently.

---

## Challenges and Solutions

### Challenge 1: Handling Long Inputs
- **Problem**: Some blog posts exceed token limits for certain models.
- **Solution**: Implemented truncation logic to ensure inputs fit within model constraints without losing critical information.

### Challenge 2: Evaluating Quality Objectively
- **Problem**: Defining a consistent metric for evaluating output quality was challenging.
- **Solution**: Used a combination of regex-based scoring and qualitative feedback analysis to assess improvements iteratively.

### Challenge 3: Managing Dependencies Between Tasks
- **Problem**: Ensuring correct sequencing and data flow between dependent tasks added complexity.
- **Solution**: Adopted structured schemas and intermediate storage mechanisms to manage task outputs systematically.

### Challenge 4: Debugging API Errors
- **Problem**: Occasional API failures disrupted workflow execution.
- **Solution**: Added robust error handling and retry logic to mitigate transient issues.

---

By addressing these challenges, the workflows were optimized to deliver reliable and high-quality outputs while maintaining flexibility for future enhancements.

## References
- [OpenAI API Documentation](https://platform.openai.com/docs/guides/functioncalling)
